this表示当前上下文(context)即对调用者的引用

函数作用域
  词法作用域
     javascript的函数是在局部作用域内运行的,在局部作用域内运行的函数体可以访问其外层
     (可能是全局作用域)的变量和函数
     javascript的作用域是词法作用域
     所谓词法作用域是说其作用域在定义时(词法分析时)就确定下来了,而并非在执行时确定
     01.js

  javascript中在所有函数之外声明的变量都是全局变量
  而在函数内部声明的变量(通过var关键字声明)为局部变量
  事实上全局变量是全局对象的属性  全局函数是全局对象的属性

  局部变量又隶属于什么对象？就是调用对象(又称活动对象this)
  在执行一个函数时，函数的参数和局部变量会作为调用对象的属性进行存储
  同时,解释器会为函数创建一个执行上下文,与执行上下文对应起来的是作用域链

  作用域链是关于作用域的链,通常实现为一个链表,链表的每一个项都是一个对象
  在全局作用域中，该链中有且只有一个对象,即全局对象
  对应的,在一个函数中,作用域链上会有两个对象,第一个为调用对象,第二个为全局对象

  函数上下文是可以变化,通过Function对象的call或apply来修改函数的执行上下文

  在Java或c/c++等语言中,方法(函数)只能依附于对象而存在不是独立的.
  而在Javascript中函数也是一种对象 并非其他任何对象一部分

闭包
  由于在javascript中,函数是对象,对象是属性的集合,而属性值又可以是对象,则在函数内定义
  函数称为理所当然,如果在函数func内部声明函数inner,然后在函数func外部调用函数inner
  这个过程就形成闭包

  闭包问题：
  1 内存泄露
    javascript的解释器都具备垃圾回收机制,一般采用的是引用计数的形式如果一个对象
    的引用计数为零,则垃圾回收机制会将其回收,这个过程是自动的。

    设置为null

  2 闭包的执行上下文


面向对象
  在面向对象过程调用构造器函数的contstruct这个内部属性
  this = Object.create(Fn.prototype);

  书中Page78说创建一个空对象是错误的。

  如果不使用new操作符,相当于告诉函数调用[[call]]这个内部属性
  this是调用对象 执行上下文

函数式的javascript
  javascript的编程方式对函数式编程支持了

  函数式编程特点
  1 函数为第一等元素不依赖于其他对象而存在,可以独立存在
  例如在java中函数必须依赖对象

  2 函数可以保持自己内部的数据,函数的运算对外部无副作用(修改可外部的全局变量的状态等),

    关于函数可以保持自己内部的数据这一特性称为闭包 04.js
