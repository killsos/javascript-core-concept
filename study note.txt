this表示当前上下文(context)即对调用者的引用

函数作用域
  词法作用域
     javascript的函数是在局部作用域内运行的,在局部作用域内运行的函数体可以访问其外层
     (可能是全局作用域)的变量和函数
     javascript的作用域是词法作用域
     所谓词法作用域是说其作用域在定义时(词法分析时)就确定下来了,而并非在执行时确定
     01.js

  javascript中在所有函数之外声明的变量都是全局变量
  而在函数内部声明的变量(通过var关键字声明)为局部变量
  事实上全局变量是全局对象的属性  全局函数是全局对象的属性

  局部变量又隶属于什么对象？就是调用对象(又称活动对象this)
  在执行一个函数时，函数的参数和局部变量会作为调用对象的属性进行存储
  同时,解释器会为函数创建一个执行上下文,与执行上下文对应起来的是作用域链

  作用域链是关于作用域的链,通常实现为一个链表,链表的每一个项都是一个对象
  在全局作用域中，该链中有且只有一个对象,即全局对象
  对应的,在一个函数中,作用域链上会有两个对象,第一个为调用对象,第二个为全局对象

  函数上下文是可以变化,通过Function对象的call或apply来修改函数的执行上下文

  在Java或c/c++等语言中,方法(函数)只能依附于对象而存在不是独立的.
  而在Javascript中函数也是一种对象 并非其他任何对象一部分

闭包
  由于在javascript中,函数是对象,对象是属性的集合,而属性值又可以是对象,则在函数内定义
  函数称为理所当然,如果在函数func内部声明函数inner,然后在函数func外部调用函数inner
  这个过程就形成闭包

  闭包问题：
  1 内存泄露
    javascript的解释器都具备垃圾回收机制,一般采用的是引用计数的形式如果一个对象
    的引用计数为零,则垃圾回收机制会将其回收,这个过程是自动的。

    设置为null

  2 闭包的执行上下文


面向对象
  在面向对象过程调用构造器函数的contstruct这个内部属性
  this = Object.create(Fn.prototype);

  书中Page78说创建一个空对象是错误的。

  如果不使用new操作符,相当于告诉函数调用[[call]]这个内部属性
  this是调用对象 执行上下文

函数式的javascript
  javascript的编程方式对函数式编程支持了

  函数式编程特点
  1 函数为第一等元素不依赖于其他对象而存在,可以独立存在
  例如在java中函数必须依赖对象

  2 函数可以保持自己内部的数据,函数的运算对外部无副作用(修改可外部的全局变量的状态等),

    关于函数可以保持自己内部的数据这一特性称为闭包 04.js

  匿名函数
  在函数编程语言中称之为lambda 05.js

  高阶函数

  闭包与柯里化
  所有函数式语言都支持闭包与柯里化

  何为柯里化？
  柯里化就是预先将函数的某些参数传入得到一个简单的函数,但预先传入的参数被保存在闭包中。
  08.js

  函数式编程的谓词(关系运算符如大于 小于  等于的判断等) 以及运算(加减乘除)都会以函数的形式出现

  Y-结合子
  可以做到对匿名函数使用递归

  var fact = function(x){
    return x == 0 ? 1 : x * argument.callee(x-1);
  }

  argument.callee 函数本身
  argument.caller 函数调用者

执行期上下文
  执行器上下文的概念贯穿于javascript引擎解释代码的全过程,执行器上下文一般实现为一个栈

  按照ECMAScript的规范一共有三种类型的代码:
    全局代码(游离于任何函数体之外)
    函数代码
    eval代码 eval接受字符串并对这个字符串求值

    这三种代码均在自身的执行期上下文求值,全局上下文仅有一个,而函数上下文和eval上下文则可能有多个

    引擎在调用一个函数时,进入该函数上下文,并执行函数体.函数体内可以有递归
    也可以调用其他函数(进入另外一个上下文,此时调用者被阻塞,直至返回),调用eval会有类似的情况

    引擎在初始化之后,将golbal的上文对象压入栈.image1.gif
